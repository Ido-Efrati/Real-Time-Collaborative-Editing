package RTCE.Client;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.net.Socket;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.net.UnknownHostException;
import java.util.concurrent.ExecutionException;
import javax.swing.JOptionPane;
import javax.swing.SwingUtilities;
import javax.swing.SwingWorker;
import javax.swing.Timer;
import javax.swing.text.BadLocationException;
import RTCE.Client.RTCE_View;
/*
 * thread safety argument
 * The controller communicates with the server and request real time updates from the server,
 * and update the documents on the server in real time.
 * Each client has its own controller that sits on a separate thread swing event dispatch thread.
 * Furthermore, each connection to the server is being performed on a specific socket and thread that 
 * are unique to the client. Thus the client is isolated from other clients
 * 
 * all of the actions that are related to a client server communication are performed inside
 * of a swing worker thread that prevents concurrency issues. Moreover the make request method
 * is synchronized to current that the request from a specific client will not interleave with each other
 * 
 * The constructor does not need to be synchronize because it is making a new object that is confined. 
 * Therefore, Java won't let you synchronize it. 
 * 
 * Finally we can guarantee full client functionality even with server delays and queuing of requests
 * thanks to our swing workers that perform all of the action in a background thread and update
 * the controller upon completion of their work.
 */
/**
 * The Controller part of our MVC design implementation. This is the 'brain'
 * of the client side. It is responsible for:
 * 
 *      (1) Running the client side main method.
 *      
 *      (2) Connecting to the server.
 *      
 *      (3) Handling all the events generated by the view which
 *          are triggered by the client.
 *          
 *      (4) Making the appropriate requests to the server.
 *           when needed in response to actions triggered by a user on the view.
 *           
 *      (5) Handling the response from the server.
 *      
 *      (4) Passing that information on to the Model so
 *          that it can update the view if necessary.
 *       
 * @author Philippe Schiff & Ido Efrati
 *
 */
public class RTCE_Controller implements ActionListener {
    /*
     * MVC Class Variable
     */
    private RTCE_View view;
    private RTCE_Model model;

    private static String ipAddress = null;
    private String switchTo = "";

    static PrintWriter outStream;
    static BufferedReader inStream;

    /*
     * Timers to listen for updates
     */
    private Timer listTimer = new Timer(5000,this);
    private Timer viewTimer = new Timer(2000,this);
    private Timer styleTimer = new Timer(2000, this);

    /*
     * Initial styling values to be updated and to send to the model in order to updated the view
     */
    private static int fontName = 3;
    private static int fontStyle = 0; 
    private static int fontSize = 12; 
    private static int color = 0;    

    private static boolean madeConnection = false;
    /*
     * For copy ,cut and paste
     */
    private static String clipBoard = null;

    /**
     * Constructor for the Controller. Takes the view and the
     * model that it is associated with to make an MVC pattern.
     * @param RTCE_View v, the view of the MVC.
     * @param RTCE_Model m, the model of the MVC.
     */
    public RTCE_Controller(RTCE_View v ,RTCE_Model m ) {
        view = v;
        model = m;
        listTimer.setInitialDelay(500);
        listTimer.start();
        viewTimer.setInitialDelay(100);
        styleTimer.setInitialDelay(0);

    }

    /**
     * An ActionListner that listens to the controller's timers.
     * When a timer is firing the controller will inform the model to update the view.
     * listTimer - a timer to update the list of active documents on the server.
     * viewTimer - a timer to update the view with the most up to date document.
     * styleTimer - a timer to update the view with the most up to date style per document. 
     * This is performed inside of a SwingWorker to guarantee concurrency and to prevent the GUI from 
     * freezing upon delays 
     */
    public void actionPerformed(final ActionEvent controllerEvent) {
        SwingWorker<?,?> worker = new SwingWorker<String, Void>() {
            @Override
            public String doInBackground() throws IOException {

                if (controllerEvent.getSource() == listTimer) {
                    String request= makeRequest("list");
                    return request;
                }
                if (controllerEvent.getSource() == viewTimer) {
                    String requestView = makeRequest("view");
                    return requestView;
                }
                if (controllerEvent.getSource() == styleTimer) {
                    String requestStyle = makeRequest("giveStyle");
                    return requestStyle;
                }
                throw new RuntimeException("Problem in timer actionevent.");
            }
            @Override
            public void done() {
                try {
                    /*
                     * get a current list of active documents on the server and update the tree of active
                     * documents that the user can switch to.
                     */
                    if(controllerEvent.getSource() == listTimer) {
                        String listResponse = get();
                        if(!listResponse.contains("There are no existing files on the server.")) {
                            String[] allDocsSplit = listResponse.split(" ");
                            for(String name : allDocsSplit) {
                                if(!model.getInTree().contains(name)) {
                                    model.updateDocTree(name);
                                }
                            }
                        }
                    }
                    /*
                     * get the current updated document and present the user with changes that were done
                     * by other users to the same document.
                     */
                    if(controllerEvent.getSource() == viewTimer) {
                        String viewResponse = get();
                        int beforeSet = view.getTextPane().getCaretPosition();
                        model.updateText(viewResponse);
                        int afterSet = view.getTextPane().getCaretPosition();
                        if(beforeSet <= afterSet){
                            view.getTextPane().setCaretPosition(beforeSet);
                        }
                    }
                    /*
                     * get the current styling from the server and update the user's active document with the
                     * most up to date styling that were set by users to the document.
                     */
                    if (controllerEvent.getSource() == styleTimer) {
                        String styleResponse = get();
                        String[] style = splitStyle(styleResponse);
                        setStylingForFile(style);
                        model.setViewStyle(fontName, fontStyle, fontSize, color);
                    }
                }
                catch (Exception e) {
                };
            }
        };
        worker.execute();
    }

    /**
     * a swing worker to handle all of the events from the GUI
     * The worker will make a request to the server based on the user's action on the GUI.
     * For example a click on a new button will generate a make new file request that will create a new 
     * document on the server
     * @param e an ActionEvent that was generated by one of the JComponents on the GUI
     */
    public void handleAction(final ActionEvent e) {

        SwingWorker<?,?> worker = new SwingWorker<String, Void>(){

            @Override
            public String doInBackground() throws IOException {
                /*
                 * a new document button was pressed, will generate a new document.
                 * If the user did not specify a new the document will be named untitled#.txt.
                 * If the user did specify a new , this name will be used. 
                 * If a user forgot to add a .txt suffix we will add the suffix for the user 
                 */
                if (e.getSource() == view.getNewDocButton()) {
                    String answer;
                    String newFileRequest = "";
                    answer = JOptionPane.showInputDialog("Insert a file name","");
                    if (answer != null){
                        if (answer.equals("")) {
                            newFileRequest = "new";
                        } else {
                            answer = answer.replace(" ", "");
                            if (!answer.endsWith(".txt")) {
                                answer += ".txt";
                            }
                            newFileRequest = "new " + answer;
                        }
                        if (answer.equals("") || (answer.endsWith(".txt"))
                                && !model.getInTree().contains(answer)) {
                            String documentName = makeRequest(newFileRequest);
                            return documentName;
                        }
                    }
                }

                /*
                 * a switch document button was pressed. will generate a switch to file request for the server
                 * if the user did not specify a file to switch nothing will happen.
                 */
                if (e.getSource() == view.getSwitchButton()){
                    if(!switchTo.equals("")){
                        switchTo = switchTo.replace(String.format("%n"),"");
                        String switchReq = makeRequest("switch " + switchTo);
                        return switchReq;
                    }
                }

                /*
                 * a replace one occurrence button was pressed, a request to replace first occurrence 
                 * of a word in the document will be send to the server.
                 */
                if (e.getSource() == view.getReplaceOneButton()) {
                    if (!view.getWordToReplaceText().equals("") 
                            && !view.getWordToReplaceText().equals(" ")
                            && !view.getWordToReplaceWithText().equals("")
                            && !view.getWordToReplaceWithText().equals(" ")) {

                        String replaceFrom = view.getWordToReplaceText();
                        String replaceTo = view.getWordToReplaceWithText();
                        String replaceOneReq = makeRequest("replaceOne " + URLEncoder.encode(replaceFrom, "UTF-8") 
                                + " "+ URLEncoder.encode(replaceTo, "UTF-8"));
                        return replaceOneReq;
                    }
                }

                /*
                 * a replace all occurrences button was pressed, a request to replace all occurrences 
                 * of a word in the document will be send to the server.
                 */
                if (e.getSource() == view.getReplaceAllButton()) {

                    if (!view.getWordToReplaceText().equals("") 
                            && !view.getWordToReplaceText().equals(" ")
                            && !view.getWordToReplaceWithText().equals("")
                            && !view.getWordToReplaceWithText().equals(" ")) {

                        String replaceFrom = view.getWordToReplaceText();
                        String replaceTo = view.getWordToReplaceWithText();
                        String replaceOneReq = makeRequest("replaceAll " + URLEncoder.encode(replaceFrom, "UTF-8") 
                                + " "+ URLEncoder.encode(replaceTo, "UTF-8"));
                        return replaceOneReq;
                    }
                }

                /*
                 * a plain button was pressed, a request to return to the original styling
                 *  will be send to the server.
                 */
                if(e.getSource() == view.getplainButton()) {
                    fontStyle = 0;
                    fontName = 1;
                    fontSize = 12;
                    color = 0;
                    String stylePlainReequest = makeRequest("style " + fontName + " " + fontStyle
                            + " " + fontSize + " "+ color );
                    return stylePlainReequest;
                }

                /*
                 * a bold button was pressed, a request to bold the text will be send to the server
                 */
                if(e.getSource() == view.getBoldButton()) {
                    if(fontStyle != 1) {
                        fontStyle = 1; 
                    }
                    else{
                        fontStyle = 0;
                    }
                    String styleBoldRequest = makeRequest("style " + fontName + " " + fontStyle
                            + " " + fontSize + " " + color );
                    return styleBoldRequest;
                }
                /*
                 * an italic button was pressed, a request to italic the text will be send to the server
                 */
                if(e.getSource() == view.getItalicButton()) {
                    if(fontStyle != 2) {
                        fontStyle = 2;
                    }
                    else{
                        fontStyle = 0;
                    }
                    String styleItalicRequest = makeRequest("style " + fontName + " " + fontStyle
                            + " " + fontSize + " " + color );
                    return styleItalicRequest;
                }
                /*
                 * a change to font size, a new font size was picked from the list.
                 * a request to update the font size will be send to the server.
                 */
                if(e.getSource() == view.getFontSize()) {
                    fontSize = (Integer) view.getFontSize().getSelectedItem();
                    String styleSizeRequest = makeRequest("style " + fontName + " " + fontStyle
                            + " " + fontSize + " " + color );
                    return styleSizeRequest;
                }
                /*
                 * a change to font type, a new font was picked from the list.
                 * a request to update the font type will be send to the server.
                 */
                if(e.getSource() == view.getFontName()) {
                    fontName = view.getFontName().getSelectedIndex();
                    String styleNameRequest = makeRequest("style " + fontName + " " + fontStyle
                            + " " + fontSize + " " + color );
                    return styleNameRequest;
                }
                /*
                 *  a change in color, a new color was picked from the list.
                 *  a request to update the color will be send to the server.
                 */
                if(e.getSource() == view.getColorOptions()) {
                    color = view.getColorOptions().getSelectedIndex();
                    String styleColorRequest = makeRequest("style " + fontName + " " + fontStyle
                            + " " + fontSize + " " + color );
                    return styleColorRequest;
                }
                /*
                 * the copy button was pressed, the text that was chosen by the user will be
                 * saved to the clip board. 
                 */
                if(e.getSource() == view.getCopyButton()) {
                    if(clipBoard != null){
                        clipBoard= "" ;
                    }
                    int endLocation = view.getTextPane().getSelectionEnd();
                    int startLocation=view.getTextPane().getSelectionStart(); 
                    try {
                        String textToCopy = view.getTextPane().getText(startLocation, endLocation-startLocation);
                        return textToCopy;
                    } catch (BadLocationException e1) {
                        throw new RuntimeException("BadLocationException in the copyButton doInBackGround.");
                    }
                }
                /*
                 * a cut button was pressed , the text that was chosen by the user will be saved to the
                 * clip board, and a delete request for this text will be sent to the server.
                 */
                if(e.getSource() == view.getCutButton()) {
                    if(clipBoard != null) {
                        clipBoard = "" ;
                    }
                    int endLocation = view.getTextPane().getSelectionEnd();
                    int startLocation = view.getTextPane().getSelectionStart(); 
                    try {
                        clipBoard = view.getTextPane().getText(startLocation, endLocation-startLocation);
                        return makeRequest("delete " + startLocation + " " + endLocation);
                    } catch (BadLocationException e1) {
                        throw new RuntimeException("BadLocationException in the cutButton doInBackGround.");                    }
                }
                /*
                 * the paste button was pressed, the text that was stored in the clip board will be inserted
                 * to the current caret location. An insert request will be send to the server.
                 * If no text was saved to the clip board the paste won't do anything.
                 */
                if(e.getSource() == view.getPasteButton()) {
                    if(clipBoard != null){
                        try {
                            int pos = view.getTextPane().getCaretPosition();
                            String pasteRequest = makeRequest("insert " + pos + " " + clipBoard); 
                            return pasteRequest;
                        } catch (IOException e) {
                            throw new RuntimeException("IOException in the pasteButton doInBackground.");
                        }

                    }
                }
                return "did not do anything";
            }

            @Override
            /*
             * the done gets the values of what was done in the background and enables the controller,
             * to update the model, that will update the view accordingly. (based on an MVC model).
             */
            public void done() {
                try{
                    /*
                     * after the server created a new file. The controller will update the model with the
                     * new file. This document will be added to the document list tree, will give the user
                     * a blank document and will listen to changes in styling and content from the server.
                     */
                    if (e.getSource() == view.getNewDocButton()) {
                        String response = get().trim();
                        if(!response.contains("did not do anything") && !response.equals("Invalid Request.")) {
                            model.updateText("");
                            model.updateViewTitle(response);
                            model.updateDocTree(response);
                            viewTimer.start();
                            styleTimer.restart();
                            model.releaseScreen(true);
                        }
                    }

                    /*
                     * after the server switch the user document. The controller will update the model
                     * about the switch document. The model will update the view, and will present to the user
                     * the content of the switch document. The controller will listen to updates from the server
                     * about changes in content or styling for this document.
                     */
                    if (e.getSource() == view.getSwitchButton()) {
                        String switchResponse = get();
                        if (model.getInTree().size() != 0) {
                            viewTimer.start();
                            styleTimer.restart();
                        }
                        if(!switchResponse.contains("did not do anything") && !switchResponse.equals("Invalid Request.")) {
                            model.updateViewTitle(switchTo);
                            model.updateText(switchResponse);
                            model.releaseScreen(true);
                        }
                    }

                    /*
                     * after a replace one occurrence was happened, the server return to the controller
                     * a new update document with the replaced word. the controller will inform the model
                     * to update the view.
                     */
                    if (e.getSource() == view.getReplaceOneButton()) {
                        String replaceOneResponse = get();
                        if (!replaceOneResponse.contains("did not do anything")) {
                            model.updateText(replaceOneResponse);
                        }
                    }

                    /*
                     * after a replace all occurrences was happened, the server return to the controller
                     * a new update document with the replaced word. the controller will inform the model
                     * to update the view.
                     */
                    if (e.getSource() == view.getReplaceAllButton()) {
                        String replaceAllResponse = get();
                        if (!replaceAllResponse.contains("did not do anything")) {
                            model.updateText(replaceAllResponse);
                        }
                    }

                    /*
                     * after a plain button was pressed, server returns to the controller an update on the
                     * styling of the current active document. The controller will inform the model to update
                     * the view with the original plain styling.
                     */
                    if(e.getSource() == view.getplainButton()) {
                        String plainResponse = get();
                        String[] plainStyle = splitStyle(plainResponse);
                        setStylingForFile(plainStyle);
                        model.setViewStyle(fontName, fontStyle, fontSize, color);
                    }

                    /*
                     * after a bold button was pressed, the server returns to the controller an update about
                     * the new styling. the controller will update the model to update a the view with a bold
                     * text.
                     */
                    if(e.getSource() == view.getBoldButton()) {
                        String boldResponse = get();
                        String[] boldStyle = splitStyle(boldResponse);
                        setStylingForFile(boldStyle);
                        model.setViewStyle(fontName, fontStyle, fontSize, color);
                    }

                    /*
                     * after an italic button was pressed, the server returns to the controller an update about
                     * the new styling. the controller will update the model to update a the view 
                     * with an italic text.
                     */
                    if(e.getSource() == view.getItalicButton()) {
                        String italicResponse = get();
                        String[] italicStyle = italicResponse.split(" ");
                        setStylingForFile(italicStyle); 
                        model.setViewStyle(fontName, fontStyle, fontSize, color);
                    }
                    /*
                     * after a font size was picked, the server returns to the controller an update about
                     * the new styling. the controller will update the model to update a the view with a new
                     * font size.
                     */
                    if(e.getSource() == view.getFontSize()) {
                        String sizeResponse = get();
                        String[] sizeStyle = splitStyle(sizeResponse);
                        setStylingForFile(sizeStyle);
                        model.setViewStyle(fontName, fontStyle, fontSize, color);
                    }
                    /*
                     * after a font name was picked, the server returns to the controller an update about
                     * the new styling. the controller will update the model to update a the view with a new
                     * font.
                     */
                    if(e.getSource() == view.getFontName()) {
                        String nameResponse = get();
                        String[] nameStyle = splitStyle(nameResponse);
                        setStylingForFile(nameStyle);
                        model.setViewStyle(fontName, fontStyle, fontSize, color);
                    }
                    /*
                     * after a color was picked, the server returns to the controller an update about
                     * the new styling. the controller will update the model to update a the view with a new
                     * color.
                     */
                    if(e.getSource() == view.getColorOptions()) {
                        String colorResponse = get();
                        String[] colorStyle = splitStyle(colorResponse);
                        setStylingForFile(colorStyle);
                        model.setViewStyle(fontName, fontStyle, fontSize, color);
                    }
                    /*
                     * after a copy was clicked, the text from the view will be saved to the clip board.
                     */
                    if(e.getSource() == view.getCopyButton()) {
                        clipBoard = get();
                    }
                    /*
                     * after a paste was perform the server, returns to the controller a new update of the document
                     * the controller will update the model, that will update the view to present the new 
                     * modified document.
                     */
                    if(e.getSource() == view.getPasteButton()) {
                        String pasteReq;
                        try {
                            pasteReq = get();
                            int beforeSet = view.getTextPane().getCaretPosition();
                            try {
                                if(!pasteReq.contains("did not do anything") && !pasteReq.equals("Invalid Request.")) {
                                    model.updateText(pasteReq);
                                }
                            } catch (UnsupportedEncodingException e) {
                                throw new RuntimeException("Bad encoding in paste.");
                            }
                            int afterSet = view.getTextPane().getCaretPosition();
                            if(beforeSet <= afterSet) {
                                view.getTextPane().setCaretPosition(beforeSet);
                            }
                        } catch (InterruptedException e) {
                            throw new RuntimeException("InterruptedException in pasteButton done().");
                        } catch (ExecutionException e) {
                            throw new RuntimeException("ExecutionException in the pasteButton done().");                        }
                    }
                    /*
                     * after a cut was perform the server, returns to the controller a new update of the document
                     * the controller will update the model, that will update the view to present the new 
                     * modified document.
                     */
                    if(e.getSource() == view.getCutButton()) {
                        String cutReq;

                        try {
                            cutReq = get();
                            int beforeSet = view.getTextPane().getCaretPosition();
                            try {
                                model.updateText(cutReq);
                            } catch (UnsupportedEncodingException e) {
                                throw new RuntimeException("Bad encoding in cut.");
                            }
                            int afterSet = view.getTextPane().getCaretPosition();
                            if(beforeSet <= afterSet){

                                view.getTextPane().setCaretPosition(beforeSet);
                            }
                        } catch (InterruptedException e) {
                            throw new RuntimeException("InterruptedException in the cutButton done().");                            
                        } catch (ExecutionException e) {
                            throw new RuntimeException("ExecutionException in the cutButton done().");                        
                        }
                    }

                } catch (Exception exc) {
                    throw new RuntimeException("Problem in the cutButton done() method.");
                }
            }
        };
        worker.execute();
    }

    /**
     * A method to split the styling string from the server into the 4 key components of the styling
     * maps that are stored on the server.
     * @param styleFromServer - a string that represent the current document styling.
     * @return a String array of the 4 keys that will allow the model to update the view with the new styling.
     */
    private String[] splitStyle(String styleFromServer) {
        String[] style = styleFromServer.split(" ");
        return style;

    }

    /**
     * given a list of keys of styling as Strings, translate those keys to integers.
     * The model will use the integer to detect the right styling in its maps.
     * The method is required because streams and encoding/decoding requires a string.
     * @param stylingToSet - a String array of styling keys
     */
    private void setStylingForFile(String[] stylingToSet) {
        fontName = Integer.parseInt(stylingToSet[0]);
        fontStyle = Integer.parseInt(stylingToSet[1]);
        fontSize = Integer.parseInt(stylingToSet[2]);
        color = Integer.parseInt(stylingToSet[3]); 
    }

    /**
     * set the document name that the user would like to switch to
     * @param switchString - the document name that the user asked to switch to.
     */
    public void setSwitchTo(String switchString) {
        switchTo = switchString;
    }

    /**
     * A method to set the IP address for the server connection. Enables the controller to open a socket
     * to that specific server
     * @param ip - IP address to be used in order to open the socket to the server
     */
    public void setIPAddress(String ip) {
        ipAddress = ip;
    }
    
    /**
     * A method to get the IP Address that was set for the server connections.
     * Mainly used for testing.
     */
    public String getIPAddress() {
        return ipAddress;
    }
    

    /**
     * indicate if a connection to the server was successful 
     * @return true- if a connection to the server was establish, false otherwise.
     */
    public boolean getConnectionMade() {
        return madeConnection;
    }

    /**
     * A method to handle with an insert update. Upon an insert edit in the document.
     * The controller will inform the server about the update to the document.
     * The server will return an update to the server about the new document after the insert.
     * the controller will update the model that will update the view
     * @param pos - a position that indicates where the insert took place
     * @param text- what was inserted at the given position
     */
    public  void handleInsertUpdate(final int pos, final String text) {
        SwingWorker<?,?> worker = new SwingWorker<String, Void>() {
            /*
             * the insert is being performed in a swing worker thread, to ensure concurrency 
             * and to prevent the GUI from freezing due to delays.
             */
            @Override
            public String doInBackground() throws IOException{
                try {
                    String getFromServer = makeRequest("insert " + pos + " " + text); 
                    return getFromServer;
                } catch (IOException e) {
                    throw new RuntimeException("Problem in handleInserUpdate swingworker" +
                            "in controller class.");
                }
            } 
            @Override
            public void done() {
                String insertReq;

                try {
                    insertReq = get();
                    int beforeSet = view.getTextPane().getCaretPosition();
                    try {
                        model.updateText(insertReq);
                    } catch (UnsupportedEncodingException e) {
                        throw new RuntimeException("Bad encoding in insertRequest in controller.");
                    }
                    int afterSet = view.getTextPane().getCaretPosition();

                    if(beforeSet <= afterSet){

                        view.getTextPane().setCaretPosition(beforeSet);
                    }
                } catch (InterruptedException e) {
                    throw new RuntimeException("InterruptedException in the insert request done() method.");                  
                } catch (ExecutionException e) {
                    throw new RuntimeException("ExecutionException in the insert request done() method.");                     
                }
            }
        };
        worker.execute();
    }

    /**
     * A method to handle with a delete update. Upon a delete edit in the document.
     * The controller will inform the server about the update to the document.
     * The server will return an update to the server about the new document after the insert.
     * the controller will update the model that will update the view
     * @param startLocation - a position to start delete from
     * @param startLocation- a position to end the delete at
     */
    public  void handleDeleteUpdate(final int startLocation, final int endLocation) {
        SwingWorker<?,?> worker = new SwingWorker<String, Void>(){
            @Override
            /*
             * the delete is being performed in a swing worker thread, to ensure concurrency 
             * and to prevent the GUI from freezing due to delays.
             */
            public String doInBackground() throws IOException{
                try {
                    String deleteRequest = makeRequest("delete " +startLocation+" "+endLocation);
                    return deleteRequest;
                } catch (IOException e) {
                    throw new RuntimeException("Problem in the handle delete update doInBackGround().");
                }
            }
            @Override
            public void done() {
                String deleteRequest;

                try {
                    deleteRequest = get();
                    int beforeSet = view.getTextPane().getCaretPosition();
                    try {
                        model.updateText(deleteRequest);
                    } catch (UnsupportedEncodingException e) {
                        throw new RuntimeException("Bad encoding in the delete request in the controller.");
                    }
                    int afterSet = view.getTextPane().getCaretPosition();
                    if(beforeSet <= afterSet){

                        view.getTextPane().setCaretPosition(beforeSet);
                    }

                } catch (InterruptedException e) {
                    throw new RuntimeException("InterruptedException in the delete request done() method.");                      
                } catch (ExecutionException e) {
                    throw new RuntimeException("ExecutionException in the insert request done() method.");  
                }
            }
        };
        worker.execute();

    }

    /**
     * Method to open the connection with the server.
     * Opens a data stream so that requests can be made to, and
     * read from, the server.
     * It reads the first welcome line and then keeps connection open.
     * @throws UnknownHostException
     * @throws IOException
     */
    public static void openConnection() throws UnknownHostException, IOException {
        Socket socket = new Socket(ipAddress, 4444);
        outStream    = new PrintWriter(socket.getOutputStream(), true);
        inStream = new BufferedReader(new InputStreamReader(socket.getInputStream()));
        madeConnection = true;
        JOptionPane.showMessageDialog(null, "The connection was established succesfully!");
    }

    /**
     * Method to make a request to the server. Should be used
     * when a user triggers an action that requires the server
     * to be updated. The parameter is a String that should be
     * one of the requests types from User to Server and should 
     * follow the correct protocol and grammar. (See Design.pdf)
     * 
     * If the request does not follow the protocol, however, the
     * server will respond accordingly.
     * 
     * Returns the response from the server.
     * 
     * @param String userInput, the request
     * @return String, the response from the server.
     * @throws IOException
     */
    public synchronized static String makeRequest(String userInput) throws IOException {
        String fromUser = URLEncoder.encode(userInput,"UTF-8");
        String fromUserReplace = userInput;

        String returnString = "";
        String fromServer = null;

        if (userInput.startsWith("replace")) {
            try {
                outStream.println(fromUserReplace);
                while (!(fromServer = inStream.readLine()).equals("EOF")) {

                    if (!fromServer.equals("EOF")) {
                        returnString +=  fromServer;
                    }
                    if (fromServer.equals("exit")) {
                        break;                
                    }
                }
            } catch (Exception er) {
                throw new RuntimeException("Problem in makeRequest method.");
            }
            fromUser = null;

        } else {
            try {
                outStream.println(fromUser);
                while (!(fromServer = inStream.readLine()).equals("EOF")) {

                    if (!fromServer.equals("EOF")) {
                        returnString +=  fromServer;
                    }
                    if (fromServer.equals("exit")) {
                        break;                
                    }
                }
            } catch (Exception er){ 
                throw new RuntimeException("Problem in makeRequest method.");
            }
            fromUser = null;
        }
        return URLDecoder.decode(returnString,"UTF-8");
    }

    /**
     * a method that gets the file that was opened by the user via open file button.
     * The method will inform the server to create a new document for that file
     * To insert the text that was read by the RTCE_fileReadr to the new document.
     * To switch the user to that new document.
     * If the file is already in the list , the controller will not create this file.
     * @param fileName - a name of the file that was opened by the user
     * @param fileRead - the content of the file that was opened by the user
     */
    public void setOpenFile(final String fileName, final String fileRead) {
        SwingWorker<?,?> worker = new SwingWorker<String, Void>(){
            @Override
            public String doInBackground() throws IOException {
                /*
                 * the open is being performed in a swing worker thread, to ensure concurrency 
                 * and to prevent the GUI from freezing due to delays.
                 */
                makeRequest("new " + fileName); // creates a new file
                String openResponse = makeRequest("switch " +fileName); // switch to that new file
                makeRequest("insert " + "0 " + fileRead); // insert the text from the file that was opened
                return openResponse;
            }
            @Override
            public void done() {
                String openFileResponse = null;
                try {
                    openFileResponse = get();
                } catch (InterruptedException e) {
                    throw new RuntimeException("InterruptedException in open file done() " +
                            "method. Problem opening file.");  
                } catch (ExecutionException e) {
                    throw new RuntimeException("ExecutionException in the open file " +
                            "done() method. Problem opening file.");  
                }
                if (model.getInTree().size() != 0) {
                    viewTimer.start();
                    styleTimer.restart();

                }
                if(!openFileResponse.contains("did not do anything") && !openFileResponse.equals("Invalid Request.")) {
                    model.updateViewTitle(switchTo);
                    try {
                        model.updateText(openFileResponse);
                    } catch (UnsupportedEncodingException e) {
                        throw new RuntimeException("Bad encoding in the open file in the controller class.");  
                    }
                    model.releaseScreen(true);
                }
            }
        };
        worker.execute();
    }

    /**
     * Main method to run the client side of the RTCE.
     * @param args
     */
    public static void main(final String[] args) {

        SwingUtilities.invokeLater(new Runnable() {
            @SuppressWarnings("static-access")

            public void run() {
                RTCE_View main = new RTCE_View();
                main.setDefaultCloseOperation(main.EXIT_ON_CLOSE);
                // will close swing by clicking X
                main.pack();
                main.setSize(5000, 5000);
                main.setVisible(true); 
                while (!madeConnection) {
                    try {
                        openConnection();
                    } catch (UnknownHostException e1) {
                        ipAddress = null;
                        while (ipAddress == null) {
                            ipAddress = JOptionPane.showInputDialog("The connection could not be " +
                                    "established. Please make sure Server is running.","localhost");
                        }
                    } catch (IOException e1) {
                        ipAddress = null;
                        while (ipAddress == null) {
                            ipAddress = JOptionPane.showInputDialog("The connection could not be " +
                                    "established. Please try again:","localhost");
                        }
                    }
                }
            }
        });
    }
}